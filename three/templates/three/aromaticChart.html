{% extends 'abstractbase.html' %}
{% load static %}
{% block css %}{% endblock css %}

{% block pageStyle %}
  <link rel="stylesheet" href="{% static 'three/css/animation.css' %}"/>
{% endblock pageStyle %}

{% block animation %}
  <div id="container"></div>
  <div id="back-button">
    <a style="text-decoration: none; color: #FFFFFF" href="{% url 'three:three' %}">Back</a>
  </div>
  <div id="menu"></div>
  <!-- <div id="camera1">
    <span>Camera Change</span>
  </div> -->
{% endblock %}

{% block javascript %}{% endblock javascript %}

{% block pageSpecificJavascript %}
<script type="module">
import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/build/three.module.js';
import {PDBLoader} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/loaders/PDBLoader.js';
import { CSS2DRenderer, CSS2DObject } from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/renderers/CSS2DRenderer.js';
import {TrackballControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/controls/TrackballControls.js';

  var camera, scene, renderer, labelRenderer;
  var controls
  let rotatate = false // if the rotatable object will rotate
  let showLabel = false

  // objects will be stored here to rotate later in animate
  const objects = [];
  const objects2 = [];
  const objects3 = [];

  var loader = new PDBLoader();
  var offset = new THREE.Vector3();

  const menu = document.getElementById( 'menu' );
  const initialCameraPosition = new THREE.Object3D()
  initialCameraPosition.position.z = 3000

  init(initialCameraPosition, menu);


  const startStopRotationButton = document.createElement( 'button' );
  startStopRotationButton.innerHTML = "Start/Stop rotating";
  menu.appendChild( startStopRotationButton );
  startStopRotationButton.addEventListener( 'click', generateStartStopRotationButtonCallback(), false );

  function generateStartStopRotationButtonCallback( url ) {
    return function () {
      rotatate = !rotatate
    }
  }

  const showLabelButton = document.createElement( 'button' )
  showLabelButton.innerHTML = "Show Label"
  // menu.appendChild( showLabelButton )
  showLabelButton.addEventListener( 'click', generateShowLabelButtonCallback(), false )

  function generateShowLabelButtonCallback( url ) {
    return function () {
      showLabel = !showLabel
      drawAllMolsAndLinks()
    }
  }

  // root for the whole scenegraph
  const root = new THREE.Group();
  const headerTextPlace = new THREE.Group();
  scene.add( root );
  root.add( headerTextPlace )
  headerTextPlace.position.x = -2000
  headerTextPlace.position.y = 1700
  text3dLoader(headerTextPlace, "Aromatic Chart For Class 11-12", "red", 200)

  // load the molecules from json
  const text = {% include "three/snippet/aromaticMolecules.json" %}
  const mol = JSON.parse(JSON.stringify(text))
  drawAllMolsAndLinks(mol, root);

  animate();

  // init function
  {% include 'three/snippet/drawAllMolsAndLinks.js' %}

  // init function
  {% include 'three/snippet/sceneCameraLight.js' %}

  // drawArrow function
  {% include 'three/snippet/drawArrow.js' %}

  // loadMolecule function
  {% include 'three/snippet/loadMolecule.js' %}

  // animation all
  {% include 'three/snippet/animate.js' %}

  // text3dLoader
  {% include 'three/snippet/text3dLoader.js' %}


  const objectList = []
  function traverseAdd(root){
    // if(root.type == "Mesh" || root.type == "Line"){
    //   objectList.push(root)
    // }
    if(root.name){
      // console.log(root.name)
      objectList.push(root)
    }
    if(root.children.length){
      for(let i=0;i<root.children.length;i++){
        traverseAdd(root.children[i])
      }
    }
  }
  traverseAdd(scene)
  console.log(objectList.length)

  function getCanvasRelativePosition(event) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) * canvas.width  / rect.width,
      y: (event.clientY - rect.top ) * canvas.height / rect.height,
    };
  }

  function setPickPosition(event) {
    const pos = getCanvasRelativePosition(event);
    const pickPosition = {x: 0, y: 0};

    pickPosition.x = (pos.x / canvas.width ) *  2 - 1;
    pickPosition.y = (pos.y / canvas.height) * -2 + 1;  // note we flip Y

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(pickPosition, camera);

    console.log("Working")
    // get the list of objects the ray intersected
    const intersectedObjects = raycaster.intersectObjects(objectList);

    if (intersectedObjects.length) {
      // pick the first object. It's the closest one
      if(intersectedObjects[0].object.name){
        console.log(intersectedObjects[0].object.name)
      } else {
        console.log(intersectedObjects[0].object)
      }
    }
  }

  document.addEventListener('mousedown', setPickPosition);

</script>
{% endblock pageSpecificJavascript %}
